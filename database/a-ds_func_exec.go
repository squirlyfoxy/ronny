package database

import (
	"fmt"
	"io/ioutil"
	"os/exec"
	"strings"
	"time"
)

func ReadLib(file string) ([]string, []string) {
	//Will return the contents and the imports
	contents, err := ioutil.ReadFile(file)
	if err != nil {
		panic(err)
	}

	lines := strings.Split(string(contents), "\n")

	lines = Remove(lines, "package libs")
	imports := make([]string, 0)

	//TODO:

	//Get the imports
	//imports (
	//""
	//)
	//var x bool = false
	/*for _, line := range lines {
		fmt.Println(x)
		//imports (
		//""
		//)
		if line == "imports (\n" {
			x = true
			continue
		}

		if x {
			fmt.Println(line)
			if strings.Contains(line, ")") {
				x = false
				break
			} else {
				imports = append(imports, line)
			}
		}
	}*/

	return lines, imports
}

//TODO: Needs to be refactored (the code is too long)
func CompileFunction(
	table Table,
	function Function,
) error {
	//Compile function and return result
	//Read the script of the table (and get from that only the rows of the function)

	var lines []string
	for x, tb := range database.Tables {
		exit := false

		if tb.Name == table.Name {
			for _, fn := range table.Functions {
				if fn.Name == function.Name {
					exit = true

					//Read the script of the table
					script_path := database.Scripts[x]
					content, err := ioutil.ReadFile(script_path)
					if err != nil {
						return err
					}

					//Get only the rows of the function
					lines = strings.Split(string(content), "\n")
					lines = RemoveTabsFromLines(lines) //Remove tabs from lines

					lines = lines[fn.StartLine : fn.EndLine-1]
					break
				}
			}
		}

		if exit {
			break
		}
	}

	//To execute the function, we need to transform the script into a golang script, run it and return the result

	//************************
	//Transpiler

	we_are_in_a_loop := false

	types_to_transpile := []string{}
	types_list := []string{}
	original_types_list := []string{}
	transpiled_function := ""
	var ass_var_type map[string]string = make(map[string]string)
	var modified_tyepes_args map[string][]string = make(map[string][]string)

	transpiled_script := ""
	transpiled_script += "//Autogenerated script by Ron transpiler at " + time.Now().String() + "\n"
	transpiled_script += "//Transpiled function: " + function.Name + "\n"

	transpiled_script += "package main\n"
	imports := "import (\n"

	//Read the file ./libs/date.go, remove from that the line "package libs" and add it to the transpiled script
	content_date_lib, imports_date_lib := ReadLib("./libs/date.go")
	imports += strings.Join(imports_date_lib, "\n")

	libs := strings.Join(content_date_lib, "\n")

	//Read the file ./libs/types.go, remove from that the line "package libs" and add it to the transpiled script
	content_types_lib, _ := ReadLib("./libs/types.go")

	libs += strings.Join(content_types_lib, "\n")
	libs += "\n"

	//packages_to_import := []string{} //Packages to import
	restart_index := 0
	for i, line := range lines {
		if i < restart_index {
			continue
		}

		//Comments
		if strings.HasPrefix(line, "//") {
			continue
		}

		//if line is @var, then we need to add the variable to the transpiled script
		if strings.HasPrefix(line, "@var") {
			type_to_transpile := ""

			//There are two whays to add a variable:
			// 1.
			// @var (type)
			// {
			//    Rows to select
			// } name;
			// 2.
			// @var (type) name;

			//We will create a type that contains all the rows to select
			//If the type is not a table, it will be a string, a float or a int

			var name string
			var type_var string

			//split
			line_split := strings.Split(line, " ")
			if len(line_split) == 2 { //first way
				//Get the type
				type_ := line_split[1]
				type_ = AlphanumericOnly(type_)
				i++

				//Get the list of rows to select
				rows_to_select := []string{}
				for j := i + 1; j < len(lines); j++ {
					if strings.HasPrefix(lines[j], "}") {
						restart_index = j
						spl := strings.Split(lines[j], " ")
						name = AlphanumericOnly(spl[1])
						name = strings.Replace(name, ";", "", -1)
						break
					}

					lines[j] = AlphanumericOnly(lines[j])

					rows_to_select = append(rows_to_select, lines[j])
				}
				modified_tyepes_args[name] = rows_to_select
				var extern []string
				var entered_in_extern bool

				if !Contains(types_list, type_+"_"+name) {
					//Check if the type is a table
					is_table := false
					var types_to_add_to_type map[string]string = map[string]string{}
					var original_type map[string]string = map[string]string{}
					for _, tb := range database.Tables {
						if tb.Name == type_ {
							for _, cols := range tb.Columns {
								//key: ColumnName, value: TypeAsString
								if Contains(rows_to_select, cols.Name) {
									if !cols.IsArray {
										a := false
										if cols.Type == DATE {
											types_to_add_to_type[cols.Name] = "string"
											a = true
										}

										if !a {
											types_to_add_to_type[cols.Name] = cols.TypeAsString
										}
									} else {
										a := false
										if cols.Type == DATE {
											types_to_add_to_type[cols.Name] = "[]string"
											a = true
										}

										if !a {
											types_to_add_to_type[cols.Name] = "[]" + cols.TypeAsString
										}
									}
								}

								if !cols.IsArray {
									if cols.Type == DATE {
										original_type[cols.Name] = "string"
										continue
									}

									original_type[cols.Name] = cols.TypeAsString
								} else {
									if cols.Type == DATE {
										original_type[cols.Name] = "[]string"
										continue
									}

									original_type[cols.Name] = "[]" + cols.TypeAsString
								}

								if cols.IsExtern {
									//We need to add a new type
									entered_in_extern = true
									extern = append(extern, cols.Name)
								}
							}

							is_table = true
							break
						}
					}
					if !is_table { //Is not a table but we are trying to manage it as a table, error
						return fmt.Errorf("The type of the variable is not a table 2")
					}

					//Create the type
					if !Contains(types_list, type_+"_"+name) {
						type_to_transpile = "type " + type_ + "_" + name + " struct {\n"
						for col, type_ := range types_to_add_to_type {
							type_to_transpile += "    " + col + " " + type_ + "\n"
						}
						type_to_transpile += "}\n"

						//Add the type to the list of types to transpile
						types_to_transpile = append(types_to_transpile, type_to_transpile)
						types_list = append(types_list, type_+"_"+name)
					}

					//Add the original type to the list of types to add to the type
					if !Contains(types_list, type_) { //Will be used to unmarshal the json
						type_to_transpile_2 := "type " + type_ + " struct {\n"
						for col, type_ := range original_type {
							type_to_transpile_2 += "    " + col + " " + type_ + "\n"
						}
						type_to_transpile_2 += "}\n"

						types_to_transpile = append(types_to_transpile, type_to_transpile_2)
						types_list = append(types_list, type_)
					}

					if entered_in_extern {
						for _, ex := range extern {
							if !Contains(types_list, ex) {
								//Get the table
								tb := database.GetTable(ex)
								add_type := "type " + ex + " struct {\n"
								for _, cols := range tb.Columns {
									if !cols.IsArray {
										if cols.Type == DATE {
											add_type += "    " + cols.Name + " string" + "\n"
											continue
										}

										add_type += "    " + cols.Name + " " + cols.TypeAsString + "\n"
									} else {
										if cols.Type == DATE {
											add_type += "    " + cols.Name + " []string" + "\n"
											continue
										}

										add_type += "    " + cols.Name + " []" + cols.TypeAsString + "\n"
									}
								}
								add_type += "}\n"

								types_to_transpile = append(types_to_transpile, add_type)
							}
						}
					}

					type_var = type_ + "_" + name
				}
			} else if len(line_split) == 3 { //second way
				//Get the type
				type_ := line_split[1]
				type_ = AlphanumericOnly(type_)
				name = line_split[2]
				name = strings.Replace(name, ";", "", -1)

				//Check if the type is a table
				is_table := false

				if !Contains(types_list, type_+"_"+name+"_all") {
					var types_to_add_to_type map[string]string = map[string]string{}
					for _, tb := range database.Tables {
						if tb.Name == type_ {
							for _, cols := range tb.Columns {
								//key: ColumnName, value: TypeAsString
								if !cols.IsArray {
									if cols.Type == DATE {
										types_to_add_to_type[cols.Name] = "string"
										continue
									}

									types_to_add_to_type[cols.Name] = cols.TypeAsString
								} else {
									if cols.Type == DATE {
										types_to_add_to_type[cols.Name] = "[]string"
										continue
									}

									types_to_add_to_type[cols.Name] = "[]" + cols.TypeAsString
								}
							}

							is_table = true
							break
						}
					}
					if !is_table { //Is not a table but we are trying to manage it as a table, error
						return fmt.Errorf("The type of the variable is not a table 1")
					}

					//Create the type
					if !Contains(types_list, type_+"_"+name) {
						type_to_transpile = "type " + type_ + "_" + name + " struct {\n"
						for col, type_ := range types_to_add_to_type {
							type_to_transpile += "    " + col + " " + type_ + "\n"
						}
						type_to_transpile += "}\n"

						//Add the type to the list of types to transpile
						types_to_transpile = append(types_to_transpile, type_to_transpile)
						types_list = append(types_list, type_+"_"+name)
						original_types_list = append(original_types_list, type_)
					}

					type_var = type_ + "_" + name
				}
			} else {
				return fmt.Errorf("Error in the line")
			}

			//Add the variable to the transpiled function
			transpiled_function += "	var " + name + " []" + type_var + "\n"
			continue
		}

		//If the line starts with "loop", we need to get all the data of the table before (in the transpiler will be []map[string]interface{}))
		if strings.HasPrefix(line, "loop") {
			//Split
			line_split := strings.Split(line, " ")
			// loop on [table] as [rowName]
			if len(line_split) == 5 {
				//If [table] == *, we are looping in the current table
				line_split[4] = AlphanumericOnly(line_split[4])

				t_to_split := line_split[2]
				if t_to_split == "*" {
					t_to_split = table.Name
				}
				ass_var_type[line_split[4]] = t_to_split

				t_to_get := database.GetTable(t_to_split)

				//To get the data we will make a request to the api (/api/v1/getAll/:tableName)

				//Make the request
				ip := GetLocalIP()
				transpiled_function += "resp, err := http.Get(\"http://" + ip + ":8080/api/v1/getAll/" + t_to_get.Name + "\")\n"
				if !strings.Contains(imports, "\"net/http\"") {
					imports += "\"net/http\"\n"
				}
				transpiled_function += "if err != nil {\n"
				transpiled_function += "	return \"\", err\n"
				transpiled_function += "}\n"

				//Get the data
				transpiled_function += "body, err := ioutil.ReadAll(resp.Body)\n"
				if !strings.Contains(imports, "\"io/ioutil\"") {
					imports += "\"io/ioutil\"\n"
				}
				transpiled_function += "if err != nil {\n"
				transpiled_function += "	return \"\", err\n"
				transpiled_function += "}\n"

				//Unmarshal the data
				transpiled_function += "var " + t_to_split + "_data" + " []" + t_to_get.Name + "\n"
				transpiled_function += "data_array := string(body)[12 : len(string(body))-2]\n"
				transpiled_function += "err = json.Unmarshal([]byte(data_array), &" + t_to_split + "_data)\n"
				if !strings.Contains(imports, "\"encoding/json\"") {
					imports += "\"encoding/json\"\n"
				}
				transpiled_function += "if err != nil {\n"
				transpiled_function += "	return \"\", err\n"
				transpiled_function += "}\n"

				//Prepare the loop
				transpiled_function += "	for _, " + line_split[4] + " := range " + t_to_split + "_data {\n"
				we_are_in_a_loop = true //WHAT IF WE HAVE A LOOP IN A LOOP?

				restart_index = i + 1

				continue
			} else {
				return fmt.Errorf("Error in the line [", i, "]")
			}
		}

		//If starts with "if"
		if strings.HasPrefix(line, "if") {
			//write the if in the transpiled function
			split_line := strings.Split(line, " ")
			split_line[3] = AlphanumericOnly(split_line[3])

			//Split split_line[1] "."
			split_line_1 := strings.Split(split_line[1], ".")
			if len(split_line_1) == 3 {
				//The first should be the name of the variable
				split_line_1[0] = AlphanumericOnly(split_line_1[0])
				//Get the type of the variable
				type_var := ass_var_type[split_line_1[0]]
				//Get tha table
				table_to_get := database.GetTable(type_var)
				//At pos 1 we have the column
				column_to_get := split_line_1[1]

				//loop throught columns
				for _, col := range table_to_get.Columns {
					if col.Name == column_to_get {
						switch col.Type {
						case DATE:
							//We neeto to: ToDate(split_line_1[0].split_line_1[1]).split_line_1[2]
							transpiled_function += "if ToDate(" + split_line_1[0] + "." + split_line_1[1] + ")." + split_line_1[2] + split_line[2] + split_line[3] + " {\n"
							break
						}
					}
				}
			} else {
				transpiled_function += split_line[0] + " " + split_line[1] + split_line[2] + split_line[3] + " {\n"
			}

			//We are in an if
			for j := i + 1; j < len(lines); j++ {
				line = lines[j]
				if strings.HasPrefix(line, "{") {
					continue
				}

				if strings.HasPrefix(line, "}") {
					//We are out of the if
					restart_index = j + 1
					break
				}

				//If variable.Add(value), append
				//Split by .
				if strings.Contains(line, ".Add") {
					line_split := strings.Split(line, ".")
					if len(line_split) == 2 {
						line_split[1] = strings.Replace(line_split[1], ";", "", -1)
						line_split[1] = strings.Replace(line_split[1], "Add(", "", -1)
						line_split[1] = strings.Replace(line_split[1], ")", "", -1)
						line_split[1] = AlphanumericOnly(line_split[1])

						//Append the value to the variable
						if Contains(original_types_list, line_split[0]) {
							transpiled_function += "	" + line_split[0] + " = append(" + line_split[0] + ", " + line_split[1] + ")\n"
						} else {
							//We need to append the value to the variable but the variable type is the one that has been modified (differs in rows)
							type_var := ""
							for _, type__ := range types_list {
								if !Contains(original_types_list, type__) {
									type_var = type__
									break
								}
							}

							transpiled_function += "	" + line_split[0] + " = append(" + line_split[0] + ", " + type_var + "{\n"

							//SAplit type_var by _, get the first
							type_var_split := strings.Split(type_var, "_")

							//Get the table
							table_to_get := database.GetTable(type_var_split[0])

							for _, column := range table_to_get.Columns {
								//modified_tyepes_args
								if ContainsInAMapOfStringArray(modified_tyepes_args, column.Name) {
									transpiled_function += "		" + column.Name + ": " + line_split[1] + "." + column.Name + ",\n"
								}
							}
							transpiled_function += "	})\n"
						}
					}
				}

				//restart_index = j + 1
			}
			transpiled_function += "	}\n"
			continue
		}

		//If contains return
		if strings.Contains(line, "return") {
			if we_are_in_a_loop {
				transpiled_function += "	}\n"
				we_are_in_a_loop = false
			}

			//Split by " "
			split_line := strings.Split(line, " ")
			split_line[1] = AlphanumericOnly(split_line[1])

			//marshal
			transpiled_function += "	json_data, err := json.Marshal(" + split_line[1] + ")\n"
			//Check if the encoding/json package is imported
			if !strings.Contains(imports, "\"encoding/json\"") {
				imports += "\"encoding/json\"\n"
			}

			transpiled_function += "	if err != nil {\n"
			transpiled_function += "		return \"\", err\n"
			transpiled_function += "	}\n"

			transpiled_function += "	return string(json_data), nil\n"

			continue
		}
	}
	imports += "\"fmt\"\n"
	imports += ")\n"

	transpiled_script += imports
	transpiled_script += libs
	transpiled_script += strings.Join(types_to_transpile, "\n")
	transpiled_script += "func " + function.Name + "() (string, error) {\n" + transpiled_function + "}\n"

	//Main function
	transpiled_script += "func main() {\n"
	transpiled_script += "	res, err := " + function.Name + "()\n"
	transpiled_script += "	if err != nil {\n"
	transpiled_script += "		panic(err)\n"
	transpiled_script += "	}\n"
	transpiled_script += "	fmt.Println(res)\n"
	transpiled_script += "}\n"

	//Save the transpiled function
	ioutil.WriteFile("./transpiled_functions/"+function.Name+".go", []byte(transpiled_script), 0644)

	//Compile the created file in ./db/bin
	cmd := exec.Command("go", "build", "-o", "./db/bin/"+function.Name, "./transpiled_functions/"+function.Name+".go")
	err := cmd.Run()
	if err != nil {
		panic(err)
	}

	fmt.Println("	-> Transpiled function: " + function.Name + " compiled successfully in ./db/bin")

	return nil
}
