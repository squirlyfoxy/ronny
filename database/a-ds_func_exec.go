package database

import (
	"fmt"
	"io/ioutil"
	"strings"
	"time"
)

func ExecuteFunction(
	table Table,
	function Function,
) (interface{}, error) {
	//Execute function and return result
	//Read the script of the table (and get from that only the rows of the function)

	var lines []string
	for x, tb := range database.Tables {
		exit := false

		if tb.Name == table.Name {
			for _, fn := range table.Functions {
				if fn.Name == function.Name {
					exit = true

					//Read the script of the table
					script_path := database.Scripts[x]
					content, err := ioutil.ReadFile(script_path)
					if err != nil {
						return nil, err
					}

					//Get only the rows of the function
					lines = strings.Split(string(content), "\n")
					lines = RemoveTabsFromLines(lines) //Remove tabs from lines

					lines = lines[fn.StartLine : fn.EndLine-1]
					break
				}
			}
		}

		if exit {
			break
		}
	}

	//To execute the function, we need to transform the script into a golang script, run it and return the result

	//************************
	//Transpiler

	we_are_in_a_loop := false

	types_to_transpile := []string{}
	types_list := []string{}
	original_types_list := []string{}
	transpiled_function := ""
	var modified_tyepes_args map[string][]string = make(map[string][]string)

	transpiled_script := ""
	transpiled_script += "//Autogenerated script by Ron transpiler at " + time.Now().String() + "\n"
	transpiled_script += "//Transpiled function: " + function.Name + "\n"

	transpiled_script += "package main\n"
	transpiled_script += "import (\n"
	transpiled_script += "\t\"encoding/json\"\n"

	//Read the file ./libs/date.go, remove from that the line "package libs" and add it to the transpiled script
	content_lns, err := ioutil.ReadFile("./libs/date.go")
	if err != nil {
		return nil, err
	}

	lns_types := strings.Split(string(content_lns), "\n")[1:]

	//Get from the lns_types the imports of the date.go file
	for _, ln := range lns_types {
		if strings.HasPrefix(ln, "import") {
			a := strings.TrimPrefix(ln, "import ")
			//add to transpiled_script at the import a
			transpiled_script += a + "\n"

			//remove the import from the lns_types
			lns_types = Remove(lns_types, ln)

			break
		}
	}

	transpiled_script += ")\n"
	transpiled_script += strings.Join(lns_types, "\n")

	//Read the file ./libs/types.go, remove from that the line "package libs" and add it to the transpiled script
	content_lns, err = ioutil.ReadFile("./libs/types.go")
	if err != nil {
		return nil, err
	}

	lns_types = strings.Split(string(content_lns), "\n")[1:]
	transpiled_script += strings.Join(lns_types, "\n")

	//packages_to_import := []string{} //Packages to import
	restart_index := 0
	for i, line := range lines {
		if i < restart_index {
			continue
		}

		//if line is @var, then we need to add the variable to the transpiled script
		if strings.HasPrefix(line, "@var") {
			type_to_transpile := ""

			//There are two whays to add a variable:
			// 1.
			// @var (type)
			// {
			//    Rows to select
			// } name;
			// 2.
			// @var (type) name;

			//We will create a type that contains all the rows to select
			//If the type is not a table, it will be a string, a float or a int

			var name string
			var type_var string

			//split
			line_split := strings.Split(line, " ")
			if len(line_split) == 2 { //first way
				//Get the type
				type_ := line_split[1]
				type_ = AlphanumericOnly(type_)
				i++

				//Get the list of rows to select
				rows_to_select := []string{}
				for j := i + 1; j < len(lines); j++ {
					if strings.HasPrefix(lines[j], "}") {
						restart_index = j
						spl := strings.Split(lines[j], " ")
						name = AlphanumericOnly(spl[1])
						name = strings.Replace(name, ";", "", -1)
						break
					}

					lines[j] = AlphanumericOnly(lines[j])

					rows_to_select = append(rows_to_select, lines[j])
				}
				modified_tyepes_args[name] = rows_to_select

				if !Contains(types_list, type_+"_"+name) {
					//Check if the type is a table
					is_table := false
					var types_to_add_to_type map[string]string = map[string]string{}
					var original_type map[string]string = map[string]string{}
					for _, tb := range database.Tables {
						if tb.Name == type_ {
							for _, cols := range tb.Columns {
								//key: ColumnName, value: TypeAsString
								if Contains(rows_to_select, cols.Name) {
									if !cols.IsArray {
										types_to_add_to_type[cols.Name] = cols.TypeAsString
									} else {
										types_to_add_to_type[cols.Name] = "[]" + cols.TypeAsString
									}
								}

								if !cols.IsArray {
									original_type[cols.Name] = cols.TypeAsString
								} else {
									original_type[cols.Name] = "[]" + cols.TypeAsString
								}
							}

							is_table = true
							break
						}
					}
					if !is_table { //Is not a table but we are trying to manage it as a table, error
						return nil, fmt.Errorf("The type of the variable is not a table 2")
					}

					//Create the type
					if !Contains(types_list, type_+"_"+name) {
						type_to_transpile = "type " + type_ + "_" + name + " struct {\n"
						for col, type_ := range types_to_add_to_type {
							type_to_transpile += "    " + col + " " + type_ + "\n"
						}
						type_to_transpile += "}\n"

						//Add the type to the list of types to transpile
						types_to_transpile = append(types_to_transpile, type_to_transpile)
						types_list = append(types_list, type_+"_"+name)
					}

					//Add the original type to the list of types to add to the type
					if !Contains(types_list, type_) { //Will be used to unmarshal the json
						type_to_transpile += "type " + type_ + " struct {\n"
						for col, type_ := range original_type {
							type_to_transpile += "    " + col + " " + type_ + "\n"
						}
						type_to_transpile += "}\n"

						types_to_transpile = append(types_to_transpile, type_)
						types_list = append(types_list, type_)
					}

					type_var = type_ + "_" + name

					transpiled_script += type_to_transpile + "\n\n"
				}
			} else if len(line_split) == 3 { //second way
				//Get the type
				type_ := line_split[1]
				type_ = AlphanumericOnly(type_)
				name = line_split[2]
				name = strings.Replace(name, ";", "", -1)

				//Check if the type is a table
				is_table := false

				if !Contains(types_list, type_+"_"+name+"_all") {
					var types_to_add_to_type map[string]string = map[string]string{}
					for _, tb := range database.Tables {
						if tb.Name == type_ {
							for _, cols := range tb.Columns {
								//key: ColumnName, value: TypeAsString
								if !cols.IsArray {
									types_to_add_to_type[cols.Name] = cols.TypeAsString
								} else {
									types_to_add_to_type[cols.Name] = "[]" + cols.TypeAsString
								}
							}

							is_table = true
							break
						}
					}
					if !is_table { //Is not a table but we are trying to manage it as a table, error
						return nil, fmt.Errorf("The type of the variable is not a table 1")
					}

					//Create the type
					if !Contains(types_list, type_+"_"+name) {
						type_to_transpile = "type " + type_ + "_" + name + " struct {\n"
						for col, type_ := range types_to_add_to_type {
							type_to_transpile += "    " + col + " " + type_ + "\n"
						}
						type_to_transpile += "}\n"

						//Add the type to the list of types to transpile
						types_to_transpile = append(types_to_transpile, type_to_transpile)
						types_list = append(types_list, type_+"_"+name)
						original_types_list = append(original_types_list, type_)

						transpiled_script += type_to_transpile + "\n"
					}

					type_var = type_ + "_" + name
				}
			} else {
				return nil, fmt.Errorf("Error in the line")
			}

			//Add the variable to the transpiled function
			transpiled_function += "	var " + name + " []" + type_var + "\n"
			continue
		}

		//If the line starts with "loop", we need to get all the data of the table before (in the transpiler will be []map[string]interface{}))
		if strings.HasPrefix(line, "loop") {
			//Split
			line_split := strings.Split(line, " ")
			// loop on [table] as [rowName]
			if len(line_split) == 5 {
				//If [table] == *, we are looping in the current table
				line_split[4] = AlphanumericOnly(line_split[4])

				t_to_split := line_split[2]
				if t_to_split == "*" {
					t_to_split = table.Name
				}

				t_to_get := database.GetTable(t_to_split)

				//To get the data we will make a request to the api (/api/v1/getAll/:tableName)

				//Make the request
				ip := GetLocalIP()
				transpiled_function += "resp, err := http.Get(\"http://" + ip + ":8080/api/v1/getAll/" + t_to_get.Name + "\")\n"
				transpiled_function += "if err != nil {\n"
				transpiled_function += "	return nil, err\n"
				transpiled_function += "}\n"

				//Get the data
				transpiled_function += "body, err := ioutil.ReadAll(resp.Body)\n"
				transpiled_function += "if err != nil {\n"
				transpiled_function += "	return nil, err\n"
				transpiled_function += "}\n"

				//Unmarshal the data
				transpiled_function += "var " + t_to_split + "_data" + " []" + t_to_get.Name + "\n"
				transpiled_function += "err = json.Unmarshal(body, &" + t_to_split + "_data)\n"
				transpiled_function += "if err != nil {\n"
				transpiled_function += "	return nil, err\n"
				transpiled_function += "}\n"

				//Prepare the loop
				transpiled_function += "	for _, " + line_split[4] + " := range " + t_to_split + "_data {\n"
				we_are_in_a_loop = true //WHAT IF WE HAVE A LOOP IN A LOOP?

				restart_index = i + 1

				continue
			} else {
				return nil, fmt.Errorf("Error in the line [", i, "]")
			}
		}

		//If starts with "if"
		if strings.HasPrefix(line, "if") {
			//write the if in the transpiled function
			split_line := strings.Split(line, " ")
			split_line[3] = AlphanumericOnly(split_line[3])
			transpiled_function += split_line[0] + " " + split_line[1] + split_line[2] + split_line[3] + " {\n"
			//We are in an if
			for j := i + 1; j < len(lines); j++ {
				line = lines[j]
				if strings.HasPrefix(line, "{") {
					continue
				}

				if strings.HasPrefix(line, "}") {
					//We are out of the if
					restart_index = j + 1
					break
				}

				//If variable.Add(value), append
				//Split by .
				if strings.Contains(line, ".Add") {
					line_split := strings.Split(line, ".")
					if len(line_split) == 2 {
						line_split[1] = strings.Replace(line_split[1], ";", "", -1)
						line_split[1] = strings.Replace(line_split[1], "Add(", "", -1)
						line_split[1] = strings.Replace(line_split[1], ")", "", -1)
						line_split[1] = AlphanumericOnly(line_split[1])

						//Append the value to the variable
						if Contains(original_types_list, line_split[0]) {
							transpiled_function += "	" + line_split[0] + " = append(" + line_split[0] + ", " + line_split[1] + ")\n"
						} else {
							//We need to append the value to the variable but the variable type is the one that has been modified (differs in rows)
							type_var := ""
							for _, type__ := range types_list {
								if !Contains(original_types_list, type__) {
									type_var = type__
									break
								}
							}

							transpiled_function += "	" + line_split[0] + " = append(" + line_split[0] + ", " + type_var + "{\n"

							//SAplit type_var by _, get the first
							type_var_split := strings.Split(type_var, "_")

							//Get the table
							table_to_get := database.GetTable(type_var_split[0])

							for _, column := range table_to_get.Columns {
								//modified_tyepes_args
								if ContainsInAMapOfStringArray(modified_tyepes_args, column.Name) {
									transpiled_function += "		" + column.Name + ": " + line_split[1] + "." + column.Name + ",\n"
								}
							}
							transpiled_function += "	})\n"
						}
					}
				}

				//restart_index = j + 1
			}
			continue
		}

		//If starts with "return"
		if strings.HasPrefix(line, "return") {
			//Remove ;
			line = strings.Replace(line, ";", "", -1)

			//Split
			line_split := strings.Split(line, " ")

			transpiled_function += "	" + line_split[0] + " " + line_split[1] + "\n"
		}
	}

	if we_are_in_a_loop {
		transpiled_function += "	}\n"
		we_are_in_a_loop = false
	}

	transpiled_function += "}\n"
	transpiled_script += "func " + function.Name + "() ([]map[string]interface{}, error) {\n" + transpiled_function + "}\n"

	//Main function
	transpiled_script += "func main() {\n"
	transpiled_script += "	" + function.Name + "()\n"
	transpiled_script += "}\n"

	//Save the transpiled function
	ioutil.WriteFile("./transpiled_functions/"+function.Name+".go", []byte(transpiled_script), 0644)

	//TODO: COMPILE THE CREATED FILE

	//TODO: RUN THE COMPILED FILE

	//TODO: GET THE RESULT

	return nil, nil
}

func ToString(row map[string]interface{}) string {
	return fmt.Sprintf("%v", row)
}
